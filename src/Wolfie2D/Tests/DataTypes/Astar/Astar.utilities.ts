import Navmesh from "../../../Pathfinding/Navmesh";
import Vec2 from "../../../DataTypes/Vec2";
import GraphUtils from "../../../Utils/GraphUtils";
import Stack from "../../../DataTypes/Collections/Stack";
import SeedRandom from "seed-random";
import PositionGraph from "../../../DataTypes/Graphs/PositionGraph";
import * as fs from 'fs';
import path from 'path'

/**
 * Contains helper functions used to test Astar. These functions are done
 * every time the tests are ran and are ran similarly in every run.
 * 
 * @author TZMCNALLY
 */

/**
 * Generates a path from start to goal in the mesh using astar.
 * @param mesh The mesh being navigated on
 * @param to the location of the goal
 * @param from the location of the start
 * @returns the path generated by astar
*/

export function createPath(mesh: Navmesh, to: Vec2, from: Vec2) {

    let start = mesh.graph.snap(to);
    let end = mesh.graph.snap(from);

    let pathStack = new Stack<Vec2>(mesh.graph.numVertices);
    
    // Push the final position in the graph
    pathStack.push(mesh.graph.positions[end]);

    // Use A* on the mesh's PositionGraph to find a path from start to end
    let parent: number[] | null = GraphUtils.astarPositional(mesh.graph, start, end);

    return parent;
}

/**
 * Generates an array of meshes along with their start, goal, and expected output.
 * 
 * These meshes are being generated deterministically, meaning that given a seed, it will
 * always use the same random number to generate the same "random" meshes in the same order. 
 * This ensures that we can make many different meshes while also ensuring consistency in
 * distribution during testing. 
 * 
 * We are extracting the results of astar on these meshes using an external json file
 * (Astar.expected.json). As the number or scale of test cases become larger, it's expected
 * that all test cases will be transferred over into the json file.
 * 
 * @returns an array of objects describing meshes and their metadata for testing purposes
*/

export function generateRandomMeshes() {
    let cases = [] // the array of generated test cases
    let caseCount = 0 // the current case we are generating
    const seed = '4567' // the seed used to generate the cases

    /*
     * These are settings that you can change to generate different navmeshes.
     * Note that if you change the seed, you must use the populate_expected script
     * to replace the expected results for the randomly generated meshes.
     */
    let dims = new Vec2(10, 10); 
    const r = SeedRandom(seed) 
    const expectedResults = JSON.parse(fs.readFileSync(path.resolve(__dirname, './Astar.expected.json'), 'utf-8')) // Use this for testing

    /*
     * To ensure a diverse range of test cases, we use many different object densities.
     * Object density is the ratio of the number of obstacles to the number of nodes in a graph.
     */
    for(let objDensity = .1; objDensity < .6; objDensity += .01) {
        let graph = new PositionGraph()
        
        // Populate the mesh with nodes
        for (let i = 0; i < dims.x; i++) {
            for (let j = 0; j < dims.y; j++) {
                graph.addPositionedNode(new Vec2(i, j));
            }
        }
        
        for (let i = 0; i < dims.x * dims.y; i++) {
            
            /*
             * We use the seed to randomly generate a float whenever we need to choose whether 
             * to add a certain edge to a node or not.
            */
            let currSeed = r();

            /*
             * If the node already has edges, then we can safely randomly choose whether to add more 
             * edges to it without having navigable nodes with no edges.
             */
            if(graph.getEdges(i) != null) {
                if ((i + 1) % dims.x !== 0 && currSeed > objDensity)
                    graph.addEdge(i, i + 1);

                currSeed = r();
                // Create edge below
                if (i + dims.x < graph.numVertices && currSeed > objDensity)
                    graph.addEdge(i, i + dims.x);
            }

            /*
            * If this node doesn't have edges, then we just add as many more edges to it as possible.
            * Of course, this skews how "random" our graph generation is. But for now, it's satisfactory
            * for initial testing purposes.
            */
            else {
                
                if ((i + 1) % dims.x !== 0)
                    graph.addEdge(i, i + 1);

                // Create edge below
                if (i + dims.x < graph.numVertices)
                    graph.addEdge(i, i + dims.x);
            }
        }

        // We also randomly generate where the start and goals are in the meshes.
        let to = new Vec2(Math.floor(r() * dims.x), Math.floor(r() * dims.x))
        let from = new Vec2(Math.floor(r() * dims.x), Math.floor(r() * dims.x))
        let mesh = new Navmesh(graph)

        // Push the mesh and its metadata to the array
        cases.push({
            mesh: mesh,
            to: to,
            from: from,
            expected: expectedResults.randomlyGeneratedMeshResults[caseCount]
        })

        caseCount++;
    }

    return cases
}